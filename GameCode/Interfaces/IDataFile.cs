using System.Collections.Generic;
using System.Buffers;
using DataBuildSystem;
using GameCore;

namespace GameData
{
    [Flags]
    public enum DataCookResult : ushort
    {
        None = 0x0000,
        UpToDate = 0x0001,
        SrcChanged = 0x0002,
        SrcMissing = 0x0004,
        DstChanged = 0x0008,
        DstMissing = 0x0010,
        VerChanged = 0x0100, // Version of the compiler has changed
        Error = 0x8000,
    }

    /// <summary>
    /// The data compiler interface.
    ///
    /// A data compiler is a class that takes one or more source files and compiles it into one or more destination files.
    /// The resulting FileId is the identifier and references one or more (compiled) files in the Bigfile.
    ///
    /// The signature uniquely identifies the DataFile, mostly it is the hash of:
    /// - The compiler type name
    /// - The source filenames
    /// See @BuildSignature
    /// </summary>
    public interface IDataFile
    {
        ///<summary>
        /// A signature is generated from specific properties.
        /// For example: The CopyCompiler should write the type name 'CopyCompiler' as well as the SrcFilename into the Writer stream.
        ///</summary>
        void BuildSignature(IBinaryWriter writer);

        Hash160 Signature { get; set; }

        ///<summary>
        /// Write all the necessary properties and data to the stream
        ///</summary>
        void SaveState(IBinaryWriter writer);

        ///<summary>
        /// Read all the properties and data from the stream in the same order and type as they were written
        ///</summary>
        void LoadState(IBinaryReader reader);

        ///<summary>
        /// Take the properties from a previous instance as this instance (e.g. 'Copy Constructor')
        ///</summary>
        void CopyConstruct(IDataFile dc);

        ///<summary>
        /// Return the filename of the compiled file
        ///</summary>
        string CookedFilename { get; }

        ///<summary>
        /// Return the Object that acts like a header in the game data (e.g. class Model)
        ///</summary>
        object CookedObject { get; }

        ///<summary>
        /// Execute the compiler and return the result, additionalDataFiles returns a list of one or more
        /// DataFiles that are generated by this compiler, for example a ModelCompiler can generate one
        /// or more TextureCompilers and some MaterialCompilers.
        /// This also means that in the Bigfile TOC we do not need to support 'Children' for a FileId,
        /// since the Object already knows what other DataFiles it needs and what type they are.
        ///</summary>

        DataCookResult Cook(List<IDataFile> additionalDataFiles);
    }
}
