using System.Collections.Generic;
using System.Buffers;
using DataBuildSystem;
using GameCore;

namespace GameData
{
    [Flags]
    public enum DataCookResult : ushort
    {
        None = 0x0000,
        UpToDate = 0x0001,
        SrcChanged = 0x0002,
        SrcMissing = 0x0004,
        DstChanged = 0x0008,
        DstMissing = 0x0010,
        VerChanged = 0x0100, // Version of the compiler has changed
        Error = 0x8000,
    }

    public interface IFileId
    {
        public Hash160 Signature { get; set; }
    }

    public interface ISignatureDataBase
    {
        (uint bigfileIndex, uint fileIndex) GetFileId(Hash160 signature);
        bool Register(Hash160 signature, uint bigfileIndex, uint fileIndex);
    }

    public struct DataFile : IStruct, IFileId
    {
        public DataFile(Hash160 signature, string templateType)
        {
            Signature = signature;
            StructTemplateType = templateType;
        }

        public Hash160 Signature { get; set; }

        public bool StructIsTemplate => true; // This is a template struct
        public string StructTemplateType { get; init; }

        public int StructAlign => 8; // This is the required memory alignment of the struct
        public int StructSize => 16; // This is the memory size of the struct
        public string StructName => "datafile_t"; // This is the name of the struct in the target code-base

        public void StructWrite(IGameDataWriter writer)
        {
            writer.Write((ulong)0);
            writer.WriteFileId(Signature);
        }
    }

    /// <summary>
    /// The data compiler interface.
    ///
    /// A data compiler is a class that takes one or more source files and compiles it into one or more destination files.
    /// The resulting FileId is the identifier and references one or more (compiled) files in the Bigfile.
    ///
    /// </summary>
    public interface IDataFile
    {
        ///<summary>
        /// A signature is generated from the 'stable' properties of a DataCompiler.
        /// For example: The CopyCompiler should write 'CopyCompiler' and SrcFilename into the Writer stream.
        ///</summary>
        void BuildSignature(IBinaryWriter writer);

        ///<summary>
        /// A signature uniquely identifies a DataFile
        ///</summary>
        Hash160 Signature { get; set; }

        ///<summary>
        /// Write all the necessary properties and data to the stream
        ///</summary>
        void SaveState(IBinaryWriter writer);

        ///<summary>
        /// Read all the properties and data from the stream in the same order and type as they were written
        ///</summary>
        void LoadState(IBinaryReader reader);

        ///<summary>
        /// Take the properties from a previous instance as this instance (e.g. 'Copy Constructor')
        ///</summary>
        void CopyConstruct(IDataFile dc);

        ///<summary>
        /// Return the filename of the compiled file
        ///</summary>
        string CookedFilename { get; }

        ///<summary>
        /// Return the Object that acts like a header in the game data (e.g. class Model)
        ///</summary>
        object CookedObject { get; }

        ///<summary>
        /// Execute the compiler and return the result, additionalDataFiles returns a list of one or more
        /// DataFiles that are generated by this compiler, for example a ModelCompiler can generate one
        /// or more TextureCompilers and some MaterialCompilers.
        /// This also means that in the Bigfile TOC we do not need to support 'Children' for a FileId,
        /// since the Object already knows what other DataFiles it needs and what type they are.
        ///</summary>

        DataCookResult Cook(List<IDataFile> additionalDataFiles);
    }
}
