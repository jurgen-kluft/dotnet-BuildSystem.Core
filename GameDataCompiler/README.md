# GameDataCompiler

## Signature DB

We are going to maintain a signature database that contains the signature of every IDataFile
that is generated by a compiler. 

This signature is fundamentally used to associated a IDataFile with a FileId (Bigfile-Index, File-Index).
Moreover the signature also connects to other data, like the saved State information of the IDataFile that
is used to determine if a IDataFile needs to be (re)cooked.

## DataFile (Cooking)

Execute the compiler and return the result, outAdditionalDataFiles is a list of additional
DataFiles that are generated by this compiler, for example a ModelCompiler can generate one
or more TextureCompilers and some MaterialCompilers.

This also means that in the Bigfile TOC we do not need to support 'Children' for a FileId,
since the Object already knows what other DataFiles it needs and what type they are.

## Cooked Object (the general way)

Every IDataFile generates a CookedObject, and the game code/data generator will use this CookedObject to generate C++ code/data. Currently the logic can distinguish between 2 types of CookedObjects:

- A normal class
- A class derived from IGenericStruct

## DataFile, IStruct (the other way)

A IDataFile can also return an object that is a DataFile (IStruct), by doing this it will be used to have the generated code/data appear in C++ as a kind of fileid_t:

```c++
template<typename T>
struct datafile_t
{
    T*       LoadedData;     // When loading the file and updating the pointer here, this will point to Model, Texture, Shader, etc.
    fileid_t FileId;         // The Bigfile index and File index
};
```

## Example

ModelCompiler creates a ModelData object for the CookedObject that is used in the game code/data, this Model object looks something like this:

```csharp
public sealed class ExampleModel
{
    public IDataFile   StaticMesh;
    public IDataFile[] Materials;
    public IDataFile[] Textures;
}
```
The C++ code will look something like this:
```c++
struct ExampleModel
{
    datafile_t<staticmesh_t>        StaticMesh;
    array_t<datafile_t<material_t>> Materials;
    array_t<datafile_t<texture_t>>  Textures;
};
```

The material IDataFile also returns an object that is used in the game code/data, this Material object looks something like this:

```csharp
public sealed class ExampleMaterial
{
    public IDataFile   Shader;
    public IDataFile[] Textures;
}
```
The C++ code will look something like this:

```c++
struct ExampleMaterial
{
    datafile_t<shader_t>           Shader;
    array_t<datafile_t<texture_t>> Textures;
};
```
